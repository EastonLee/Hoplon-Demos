(page "index.html"
  (:require
    [clojure.string :as str]))

(defc  state [])
(defc  error nil)
(defc  loading [])

(defc= loading? (seq loading))
(defc= sorted-state (vec (sort-by :page state)))
(defc  pages-loaded [])
(defc= prev-page (dec (apply min pages-loaded)))
(defc= next-page (inc (apply max pages-loaded)))
(defc  last-scroll 0)
(defc  hash-scroll true)
(defc  timeout-id 0)

(defn generate-numbers [n]
  (vec (map (fn [x] {:number (str x)}) (range (* (dec n) 10)
                                         (+ (* (dec n) 10) 10)))))
(defn generate-data [n]
  {(str n) {:page n
            :data (generate-numbers n)}})

(def fake-api
  (into {} (map generate-data (range 1 100))))

(defn get-page
  [p callback]
  (callback (fake-api p)))

(defn fetch-initial-page!
  [initial-page]
  (when-not @loading?
    (reset! error nil)
    (swap! loading conj :loading)
    (let [q (str initial-page)]
      (get-page q
        #(do
           (swap! loading pop)
           (when %
             (swap! state conj %)
             (swap! pages-loaded conj initial-page))
           (when-not % (reset! error "Sem mais páginas")))))))

(defn fetch-next-page!
  []
  (when-not @loading?
    (reset! error nil)
    (swap! loading conj :loading)
    (let [q (str @next-page)]
      (get-page q
        #(do
           (swap! loading pop)
           (when %
             (swap! state conj %)
             (swap! pages-loaded conj @next-page))
           (when-not % (reset! error "Sem mais páginas")))))))

(defn fetch-prev-page!
  []
  (when-not @loading?
    (reset! error nil)
    (swap! loading conj :loading)
    (let [q (str @prev-page)]
      (get-page q
        #(do
           (swap! loading pop)
           (when %
             (swap! state conj %)
             (swap! pages-loaded conj @prev-page)
             (.scrollTop (js/jQuery js/window)
               (+ (.scrollTop (js/jQuery js/window))
                  (.height (js/jQuery (str "#page-" q))))))
           (when-not % (reset! error "Sem mais páginas")))))))

(defn mostly-visible [el]
  (let [w               (js/jQuery js/window)
        vertical-scroll (.scrollTop w)
        window-height   (.height w)
        el-top          (.-top (.offset (js/jQuery el)))
        el-height       (.height (js/jQuery el))
        el-bottom       (+ el-top el-height)]
    (and (> (- el-bottom (* el-height 0.25)) vertical-scroll)
         (< el-top (+ vertical-scroll (* 0.5 window-height))))))

(with-init!
  (if (str/blank? (.-hash (.-location js/window)))
    (fetch-initial-page! 1)
    (fetch-initial-page! (js/parseInt (last (str/split (.-hash (.-location js/window)) #"/")))))

  (on! js/window :scroll
    #(let [w               (js/jQuery js/window)
           vertical-scroll (.scrollTop w)
           window-height   (.height w)
           document-height (.height (js/jQuery js/document))
           at-end?         (>= vertical-scroll
                               (* 0.9 (- document-height window-height)))
           header-height   (.height (js/jQuery "#header"))
           at-begin?       (= vertical-scroll 0)]

       (when (> (.abs js/Math (- vertical-scroll @last-scroll))
                (* 0.1 window-height))
         (reset! last-scroll vertical-scroll)
         (.each (js/jQuery ".item-page")
           (fn [i v]
             (if (mostly-visible v)
               (do
                 (js/clearTimeout @timeout-id)
                 (reset! hash-scroll false)
                 (set! (.-hash (.-location js/window))
                   (.attr (js/jQuery v) "data-url"))
                 (reset! timeout-id (js/setTimeout
                                      (fn [] (reset! hash-scroll true))
                                      500)))))))
       (if at-end?
         (fetch-next-page!)
         (when at-begin?
           (fetch-prev-page!)))))

  (on! js/window :hashchange
    #(when @hash-scroll
       (let [p (last (str/split (.-hash (.-location js/window)) #"/"))
             el (js/jQuery (str "#page-"p))]
         (if (> (.-length el) 0)
           (let [position (.position el)
                 tp (.-top position)
                 b (js/jQuery "html,body")]
             (.animate b (clj->js {:scrollTop tp})))
           (.reload (.-location js/window) false))))))

(html :lang "en"
  (head
    (meta :charset "utf-8")
    (title "Hoplon • Infinite Scroll Paginated Demo"))
  (body
    (div :id "header"
      (h1 "Infinite Scrolling")
      (p "Scroll down to see more pages..."))
    (div :id "wrapper"
      (div :id "loading" :toggle loading? "LOADING IMAGES...")
      (div :id "error" :toggle error
        "No more pages: "
        (a :href "javascript:void(0)" :click fetch-next-page! "try again"))
      (div
        (loop-tpl :bindings [{p :page d :data} sorted-state]
          (div
            :id (cell= (str "page-" p))
            :class "item-page"
            :data-url (cell= (str "#/page/" p))
            (h1 :id (cell= (str "page-" p))
              (text "Page: ~{p}"))
            (loop-tpl :bindings [{it :number} d]
              (div
                :css {:height 100}
                (h2 (text "Number: ~{it}"))))))))))

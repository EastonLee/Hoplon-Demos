(page "index.html")

(def queries
  "Flickr search API queries, will be chosen randomly and submitted to obtain
  interesting images which will be displayed in the scrolling div."
  (list
    "wtf" "omg" "meme" "spaghetti" "bananas" "motorcycles" "funny" "sad"
    "happy" "blue" "red" "green" "amazing" "awesome" "terrifying" "alabama"
    "nyc" "paris" "love" "hate" "submarines" "unicorns" "farming" "jewels"
    "sneaky" "hilarious" "underground" "space" "nasa" "flamenco" "tango"
    "castle" "tractor" "hunting" "sailing" "trouble" "goodbye" "hello"))

(defc  state    "The current list of image urls."            [])
(defc  loading  "A vector of in-progress async calls."       [])
(defc= loading? "True if there are in-progress async calls." (seq loading))

(defn swap-async!
  [async-fn result-cell loading-cell swap-fn & args]
  (when-not (seq @loading-cell)
    (swap! loading-cell conj :loading)
    (async-fn #(do (swap! loading-cell pop)
                   (apply swap! result-cell swap-fn % args)))))

(defn flickr-search
  "Given a search query and a callback function, a JSONP request to the Flickr
  API is made. The image result URLs are extracted from the response and passed
  to the provided callback function."
  [query callback]
  (let [js->clj #(js->clj % :keywordize-keys true)
        data    (clj->js {:tags query :tagmode :any :format :json})
        url     "http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?"
        parse   (fn [{link :link, {url :m} :media}] {:link link :url url})]
    (doto (.getJSON js/jQuery url data)
      (.done #(->> % js->clj :items (map parse) callback)))))

(defn fetch-images!
  "Fetch some images from the Flickr API and append them to the state cell."
  []
  (swap-async! (partial flickr-search (rand-nth queries)) state loading into))

(defmethod on! :scroll-end
  ;; Add the :scroll-end attribute, which fires its callback when the element is
  ;; scrolled down as far as it can go--to the bottom.
  [elem _ callback]
  (on! elem :scroll
    #(let [el (.-target %)
           ch (.-clientHeight el)
           sh (.-scrollHeight el)
           st (.-scrollTop    el)]
       (when (= ch (- sh st)) (callback %)))))

;; initialize the application state by fetching a batch of images
(with-init! (fetch-images!))

(html :lang "en"
  (head
    (meta :charset "utf-8")
    (title "Hoplon â€¢ Infinite Scroll Demo")
    (link :rel "stylesheet" :type "text/css" :href "css/main.css"))
  (body
    (div :id "container"
      (h1 "Infinite Scrolling")
      (p "Scroll down to see more images...")
      (div :id "wrapper"
        (div
          :id "loading"
          :fade-toggle loading?
          "LOADING IMAGES...")
        (div
          :id "scroll"
          :scroll-end fetch-images!
          (loop-tpl :bindings [{:keys [link url]} state]
            (div (a :href link :target "_blank" (img :src url)))))
        (p (a :href "https://github.com/tailrecursion/hoplon-demos/tree/master/infinite-scroll/src/index.cljs.hl" "Source Code")))))) 
